{"version":3,"file":"compiled.js","sources":["app.js","logo.js","render.js","maze.js"],"sourcesContent":["import $ from 'jquery';\nimport Hammer from 'hammerjs';\nimport CanvasView from './render';\nimport Maze from './maze';\n\nlet $canvas = $('canvas'), canvas = $canvas[0];\nlet maze = new Maze(100, 100);\n// maze.randomScatter('block');\nlet view = new CanvasView(canvas);\nwindow.view = view;\n\n$.notify.addStyle('plain', {\n\thtml: '<div><span data-notify-text/></div>',\n\tclasses: {\n\t\tbase: {\n\t\t\t'white-space': 'nowrap',\n\t\t\t'background-color': 'lightblue',\n\t\t\t'padding': '5px',\n\t\t\t'text-align': 'right',\n\t\t},\n\t\terror: {},\n\t\tsuccess: {},\n\t\tinfo: {},\n\t\twarning: {},\n\t},\n});\n$.notify.defaults({style: 'plain'});\n\nlet hammer = new Hammer.Manager($canvas[0], {\n\trecognizers: [\n\t\t[Hammer.Pan],\n\t\t[Hammer.Tap],\n\t\t[Hammer.Tap, { event: 'doubletap', taps: 2 }, ['tap']],\n\t\t[Hammer.Press],\n\t\t[Hammer.Pinch],\n\t]\n});\nlet lastPan;\nhammer.on('panstart panmove', function(e) {\n\tif (e.type === 'panstart') {\n\t\tlastPan = {x: 0, y: 0};\n\t}\n\tview.freePan(e.deltaX - lastPan.x, e.deltaY - lastPan.y);\n\tlastPan.x = e.deltaX;\n\tlastPan.y = e.deltaY;\n});\nlet scaleStartTileSize;\nhammer.on('pinchstart pinchmove pinchend', function(e) {\n\tif (e.type === 'pinchstart') {\n\t\tscaleStartTileSize = view.tileSize;\n\t}\n\tview.freeZoom(scaleStartTileSize * e.scale, true);\n});\nhammer.on('tap', function(e) {\n\tlet {x, y} = view.getTileCoords(e.center);\n\t$.notify('tap ('+x+', '+y+')');\n\tconsole.log('tap', x, y);\n});\nhammer.on('doubletap', function(e) {\n\tconsole.log(e.type, arguments);\n});\nhammer.on('press', function(e) {\n\tconsole.log(e.type, arguments);\n});\n\nMousetrap.bind('up', function() { view.panUp(); });\nMousetrap.bind('right', function() { view.panRight(); });\nMousetrap.bind('down', function() { view.panDown(); });\nMousetrap.bind('left', function() { view.panLeft(); });\nMousetrap.bind('enter', function() { view.panCenter(); });\n\n$(window).on('mousewheel', function(e) {\n\tview.freeZoom(e.deltaY < 0 ? 1.1 : 0.9);\n});\n\nfunction resizeCanvas() {\n\tvar w = $canvas.outerWidth(), h = $canvas.outerHeight(); // copy actual size\n\t$canvas.attr({width: w, height: h}); // set width and height to actual size\n\tview.requireRedraw();\n}\nresizeCanvas();\nvar resizeTimeout;\n$(window).on('resize', function() {\n\tif (resizeTimeout) {\n\t\tclearTimeout(resizeTimeout);\n\t}\n\tresizeTimeout = setTimeout(function() {\n\t\tresizeTimeout = null;\n\t\tresizeCanvas();\n\t}, 100);\n});\n\n\nconsole.log('icemaze loaded!');\n","const width = 120;\nconst height = 50;\nconst x = width/2, y = height/2;\nconst font = '24px serif';\nconst debug = false;\n\nclass Logo {\n\n\tconstructor() {\n\t\tthis.canvas = document.createElement('canvas');\n\t\tthis.canvas.width = width;\n\t\tthis.canvas.height = height;\n\n\t\tlet c2d = this.canvas.getContext('2d');\n\t\tc2d.textBaseline = 'middle';\n\t\tc2d.textAlign = 'center';\n\t\tc2d.font = font;\n\n\t\tc2d.shadowColor = \"#0077FF\";\n\t\tc2d.shadowOffsetX = 0;\n\t\tc2d.shadowOffsetY = 0;\n\t\tc2d.shadowBlur = 7;\n\t\tc2d.strokeStyle = '#33FFFF';\n\t\tc2d.strokeText('IceMaze', x, y);\n\n\t\tc2d.fillStyle = 'white';\n\t\tc2d.fillText('IceMaze', x, y);\n\n\t\tif (debug) {\n\t\t\tc2d.strokeStyle = 'green';\n\t\t\tc2d.strokeRect(0, 0, width, height);\n\t\t}\n\t}\n\n\tdraw(targetCanvas) {\n\t\ttargetCanvas.getContext('2d').drawImage(this.canvas, 0, targetCanvas.height - height);\n\t}\n\n}\n\nexport default new Logo();\n","import $ from 'jquery';\nimport logo from './logo';\n\nconst minTileSize = 9;\nconst maxTileSize = 61;\nconst frameMillis = 1000 / 60;\nconst zoomAnimMillis = 1000 / 4;\nconst panAnimPerTileMillis = 1000 / 10;\nconst debug = false;\n\nexport default class CanvasView {\n\tconstructor(canvas) {\n\t\tthis.canvas = canvas;\n\t\tthis.targetX = 0; // current pan target center tile\n\t\tthis.targetY = 0;\n\t\tthis.panX = 0; // current actual pan point in tile coordinates\n\t\tthis.panY = 0;\n\t\tthis.tileSize = 21;\n\t\tthis.redrawRequired = false;\n\t\tthis.lastRedrawTime = 0;\n\t\tthis.preDrawCallbacks = [];\n\t\tthis.postDrawCallbacks = [];\n\t\tthis.requireRedraw();\n\t}\n\n\t// returns tile coordinates corresponding to given canvas coordinates\n\tgetTileCoords({x: canvasX, y: canvasY}) {\n\t\treturn {\n\t\t\tx: Math.round(((canvasX - this.canvas.width/2) + (this.panX*this.tileSize)) / this.tileSize),\n\t\t\ty: Math.round(((this.canvas.height/2 - canvasY) + (this.panY*this.tileSize)) / this.tileSize),\n\t\t};\n\t}\n\n\t// returns canvas coordinates of top-left corner of specified tile\n\tgetCanvasCoords({x: tileX, y: tileY}) {\n\t\treturn {\n\t\t\tx: (((tileX * this.tileSize) - (this.panX*this.tileSize)) + this.canvas.width/2) - this.tileSize/2,\n\t\t\ty: -(((tileY * this.tileSize) - (this.panY*this.tileSize)) - this.canvas.height/2) - this.tileSize/2,\n\t\t};\n\t}\n\n\t// returns the viewport rect {x, y, w, h} in tile coordinates\n\tgetVisibleRect() {\n\t\tlet bottomLeft = this.getTileCoords({x: 0, y: this.canvas.height});\n\t\treturn {\n\t\t\tx: bottomLeft.x,\n\t\t\ty: bottomLeft.y,\n\t\t\tw: Math.ceil(this.canvas.width / this.tileSize),\n\t\t\th: Math.ceil(this.canvas.height / this.tileSize),\n\t\t};\n\t}\n\n\tfillTile(point, fillStyle = 'blue') {\n\t\tlet {x, y} = this.getCanvasCoords(point);\n\t\tlet c2d = this.canvas.getContext('2d');\n\t\tc2d.fillStyle = fillStyle;\n\t\tc2d.fillRect(x, y, this.tileSize, this.tileSize);\n\t}\n\n\tzoom(factor) {\n\t\tthis.zoomTo(this.tileSize * factor);\n\t}\n\n\tfreeZoom(factor, isTileSize) {\n\t\tlet targetTileSize = Math.round(isTileSize ? factor : this.tileSize * factor);\n\t\tif (targetTileSize % 2 === 0) {\n\t\t\t// scene is centered on tile center;\n\t\t\t// use odd number for target tile size so final view is pixel perfect\n\t\t\ttargetTileSize += 1;\n\t\t}\n\t\tif (targetTileSize < minTileSize) {\n\t\t\ttargetTileSize = minTileSize;\n\t\t} else if (targetTileSize > maxTileSize) {\n\t\t\ttargetTileSize = maxTileSize;\n\t\t}\n\n\t\tthis.tileSize = targetTileSize;\n\t\tthis.requireRedraw();\n\t}\n\n\t// set running zoom to new target\n\tzoomTo(targetTileSize, finishedCallback) {\n\t\ttargetTileSize = Math.round(targetTileSize);\n\t\tif (targetTileSize % 2 === 0) {\n\t\t\t// scene is centered on tile center;\n\t\t\t// use odd number for target tile size so final view is pixel perfect\n\t\t\ttargetTileSize += 1;\n\t\t}\n\t\tif (targetTileSize < minTileSize) {\n\t\t\ttargetTileSize = minTileSize;\n\t\t} else if (targetTileSize > maxTileSize) {\n\t\t\ttargetTileSize = maxTileSize;\n\t\t}\n\n\t\t// remove existing zoom step function\n\t\tthis.preDrawCallbacks = this.preDrawCallbacks.filter(function(fn) {\n\t\t\treturn !fn.zoomStepper;\n\t\t});\n\n\t\tif (targetTileSize === this.tileSize) {\n\t\t\tif (typeof finishedCallback === 'function') {\n\t\t\t\tfinishedCallback();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// build new step function\n\t\tlet initialTileSize = this.tileSize;\n\t\tlet difference = targetTileSize - initialTileSize;\n\t\tlet animStartMillis = (new Date()).getTime();\n\t\tlet stepFunction = (function() {\n\t\t\tvar percent = (this.lastRedrawTime - animStartMillis) / zoomAnimMillis;\n\t\t\tif (percent < 0) { percent = 0; }\n\t\t\telse if (percent > 1) { percent = 1; }\n\t\t\tthis.tileSize = initialTileSize + (percent * difference);\n\t\t\tif (percent < 1) {\n\t\t\t\tthis.requireRedraw(stepFunction);\n\t\t\t} else {\n\t\t\t\tconsole.log('tile size', this.tileSize);\n\t\t\t\tthis.zoomInProgress = false;\n\t\t\t\tthis.requireRedraw();\n\t\t\t\tif (typeof finishedCallback === 'function') {\n\t\t\t\t\tfinishedCallback();\n\t\t\t\t}\n\t\t\t}\n\t\t}).bind(this);\n\t\tstepFunction.zoomStepper = true;\n\t\tthis.requireRedraw(stepFunction);\n\t}\n\n\tpanUp(n = 1) {\n\t\tthis.panTo({y: this.targetY + Math.round(n)});\n\t}\n\n\tpanRight(n = 1) {\n\t\tthis.panTo({x: this.targetX + Math.round(n)});\n\t}\n\n\tpanDown(n = 1) {\n\t\tthis.panTo({y: this.targetY - Math.round(n)});\n\t}\n\n\tpanLeft(n = 1) {\n\t\tthis.panTo({x: this.targetX - Math.round(n)});\n\t}\n\n\tfreePan(canvasDiffX, canvasDiffY) {\n\t\tlet diffX = canvasDiffX / this.tileSize;\n\t\tlet diffY = canvasDiffY / this.tileSize;\n\t\tthis.panX -= diffX;\n\t\tthis.panY += diffY;\n\t\tthis.targetX -= diffX;\n\t\tthis.targetY += diffY;\n\t\tthis.requireRedraw();\n\t}\n\n\t// set running pan to nearest point\n\tpanCenter() {\n\t\tthis.panTo({x: this.panX, y: this.panY});\n\t}\n\n\t// set running pan to new target\n\tpanTo({x = this.targetX, y = this.targetY}, finishedCallback) {\n\t\tthis.targetX = Math.round(x);\n\t\tthis.targetY = Math.round(y);\n\n\t\t// remove existing panning step function\n\t\tthis.preDrawCallbacks = this.preDrawCallbacks.filter(function(fn) {\n\t\t\treturn !fn.panStepper;\n\t\t});\n\n\t\tif (this.targetX === this.panX && this.targetY === this.panY) {\n\t\t\tif (typeof finishedCallback === 'function') {\n\t\t\t\tfinishedCallback();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// build new step function\n\t\tlet initialX = this.panX, initialY = this.panY;\n\t\tlet diffX = this.targetX - initialX, diffY = this.targetY - initialY;\n\t\tlet hypotenuse = Math.sqrt(diffX*diffX + diffY*diffY);\n\t\tlet animMillis = hypotenuse * panAnimPerTileMillis;\n\t\tlet animStartMillis = (new Date()).getTime();\n\t\tlet stepFunction = (function() {\n\t\t\tvar percent = (this.lastRedrawTime - animStartMillis) / animMillis;\n\t\t\tif (percent < 0) {\n\t\t\t\tpercent = 0;\n\t\t\t}\n\t\t\tif (percent < 1) {\n\t\t\t\tthis.panX = initialX + (percent * diffX);\n\t\t\t\tthis.panY = initialY + (percent * diffY);\n\t\t\t\tthis.requireRedraw(stepFunction);\n\t\t\t} else {\n\t\t\t\tthis.panX = this.targetX;\n\t\t\t\tthis.panY = this.targetY;\n\t\t\t\tconsole.log('pan center', this.panX, this.panY);\n\t\t\t\tthis.requireRedraw();\n\t\t\t\tif (typeof finishedCallback === 'function') {\n\t\t\t\t\tfinishedCallback();\n\t\t\t\t}\n\t\t\t}\n\t\t}).bind(this);\n\t\tstepFunction.panStepper = true;\n\t\tthis.requireRedraw(stepFunction);\n\t}\n\n\trequireRedraw(preDrawCallback, postDrawCallback) {\n\t\tif (typeof preDrawCallback === 'function') {\n\t\t\tthis.preDrawCallbacks.push(preDrawCallback);\n\t\t}\n\t\tif (typeof postDrawCallback === 'function') {\n\t\t\tthis.postDrawCallbacks.push(postDrawCallback);\n\t\t}\n\t\tif (this.redrawRequired) {\n\t\t\t// redraw already pending\n\t\t\treturn;\n\t\t}\n\t\tthis.redrawRequired = true;\n\t\tif (window.requestAnimationFrame) {\n\t\t\twindow.requestAnimationFrame(this.redraw.bind(this));\n\t\t} else {\n\t\t\tlet nextFrame = frameMillis - ((new Date()).getTime() - this.lastRedrawTime);\n\t\t\twindow.setTimeout(this.redraw.bind(this), nextFrame > 0 ? nextFrame : 0);\n\t\t}\n\t}\n\n\tredraw() {\n\t\tthis.redrawRequired = false;\n\t\tthis.lastRedrawTime = (new Date()).getTime();\n\n\t\tlet preDrawCallbacks = this.preDrawCallbacks;\n\t\tthis.preDrawCallbacks = [];\n\t\tpreDrawCallbacks.forEach(function(cb){ cb(); });\n\n\t\tthis.drawGrid();\n\t\tlogo.draw(this.canvas);\n\t\tthis.fillTile({x: 0, y: 0});\n\n\t\tlet postDrawCallbacks = this.postDrawCallbacks;\n\t\tthis.postDrawCallbacks = [];\n\t\tpostDrawCallbacks.forEach(function(cb){ cb(); });\n\t}\n\n\tdrawGrid() {\n\t\tlet w = this.canvas.width, h = this.canvas.height, tileSize = this.tileSize;\n\t\tlet c2d = this.canvas.getContext('2d');\n\n\t\tc2d.clearRect(0, 0, w, h);\n\n\t\tif (debug) {\n\t\t\tc2d.lineWidth = 1;\n\t\t\tc2d.strokeStyle = 'green';\n\t\t\tc2d.strokeRect(0, 0, w, h);\n\t\t}\n\n\t\tc2d.beginPath();\n\t\tlet x = ((w-tileSize)/2)%tileSize - tileSize*(this.panX%1);\n\t\tfor (; x < w; x += tileSize) {\n\t\t\tc2d.moveTo(x, 0);\n\t\t\tc2d.lineTo(x, h);\n\t\t}\n\t\tlet y = ((h-tileSize)/2)%tileSize + tileSize*(this.panY%1);\n\t\tfor (; y < h; y += tileSize) {\n\t\t\tc2d.moveTo(0, y);\n\t\t\tc2d.lineTo(w, y);\n\t\t}\n\t\tc2d.closePath();\n\t\tc2d.lineWidth = 1;\n\t\tc2d.strokeStyle = 'rgba(0,0,0,.2)';\n\t\tc2d.stroke();\n\t}\n}\n","export default class Maze {\n\n\tconstructor(width, height) {\n\t\tthis.grid = [];\n\t\tthis.width = Math.round(width);\n\t\tthis.height = Math.round(height);\n\t}\n\n\tget(x, y, prop) {\n\t\tx = x < 0 ? this.width+(x%this.width) : x%this.width;\n\t\ty = y < 0 ? this.height+(y%this.height) : y%this.height;\n\t\tlet row = this.grid[y] || (this.grid[y].cellCount=0, this.grid[y] = []);\n\t\tlet cell = row[x] || (row.cellCount++, row[x] = {});\n\t\treturn prop ? cell[prop] : cell;\n\t}\n\n\ttoggle(x, y, prop, state) {\n\t\tlet cell = this.get(x, y);\n\t\treturn (cell[prop] = (state === undefined ? !cell[prop] : state));\n\t}\n\n\tclear(x, y) {\n\t\tx = x < 0 ? this.width+(x%this.width) : x%this.width;\n\t\ty = y < 0 ? this.height+(y%this.height) : y%this.height;\n\t\tlet row = this.grid[y];\n\t\tif (row && row[x]) {\n\t\t\tif (x >= 0) {\n\t\t\t\trow.splice(x, 1);\n\t\t\t} else {\n\t\t\t\trow[x] = undefined;\n\t\t\t}\n\t\t\trow.cellCount--;\n\t\t\tif (row.cellCount === 0) {\n\t\t\t\tif (y >= 0) {\n\t\t\t\t\tthis.grid.splice(y, 1);\n\t\t\t\t} else {\n\t\t\t\t\tthis.grid[y] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// randomCover(prop) {\n\t// \t// TODO ensure prop is applied to at least one cell in every row and column\n\t//\n\t// \tlet arr = new Array(this.width);\n\t//\n\t// \tlet x = 0, y = 0;\n\t// \twhile (x < this.width && y < this.height) {\n\t// \t\tif (x < this.width && y < this.height) {\n\t//\n\t// \t\t}\n\t// \t}\n\t//\n\t// }\n\n}\n"],"names":["resizeCanvas","w","$canvas","outerWidth","h","outerHeight","attr","width","height","requireRedraw","x","y","font","debug","Logo","canvas","document","createElement","c2d","this","getContext","textBaseline","textAlign","shadowColor","shadowOffsetX","shadowOffsetY","shadowBlur","strokeStyle","strokeText","fillStyle","fillText","strokeRect","targetCanvas","drawImage","minTileSize","maxTileSize","frameMillis","zoomAnimMillis","panAnimPerTileMillis","CanvasView","targetX","targetY","panX","panY","tileSize","redrawRequired","lastRedrawTime","preDrawCallbacks","postDrawCallbacks","canvasX","canvasY","Math","round","tileX","tileY","bottomLeft","getTileCoords","ceil","point","getCanvasCoords","fillRect","factor","zoomTo","isTileSize","targetTileSize","finishedCallback","filter","fn","zoomStepper","initialTileSize","difference","animStartMillis","Date","getTime","stepFunction","percent","log","zoomInProgress","bind","n","panTo","canvasDiffX","canvasDiffY","diffX","diffY","panStepper","initialX","initialY","hypotenuse","sqrt","animMillis","preDrawCallback","postDrawCallback","push","window","requestAnimationFrame","redraw","nextFrame","setTimeout","forEach","cb","drawGrid","draw","fillTile","clearRect","lineWidth","beginPath","moveTo","lineTo","closePath","stroke","Maze","grid","prop","row","cellCount","cell","state","get","undefined","splice","$","view","notify","addStyle","defaults","style","hammer","Hammer","Manager","Pan","Tap","event","taps","Press","Pinch","lastPan","on","e","type","freePan","deltaX","deltaY","scaleStartTileSize","freeZoom","scale","center","arguments","Mousetrap","panUp","panRight","panDown","panLeft","panCenter","resizeTimeout","console"],"mappings":"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"}