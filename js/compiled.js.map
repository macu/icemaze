{"version":3,"file":"compiled.js","sources":["app.js","maze.js","mazeview.js","logo.js","canvasview.js"],"sourcesContent":["import $ from 'jquery';\nimport Hammer from 'hammerjs';\nimport CanvasView from './canvasview';\nimport {Maze, db} from './maze';\n\nlet $canvas = $('canvas'), canvas = $canvas[0];\nlet maze = new Maze('a');\nlet cv = new CanvasView(canvas, maze);\n\n// for debugging\nwindow.Maze = Maze;\nwindow.maze = maze;\nwindow.mazeDb = db;\nwindow.canvasView = cv;\nwindow.mazeView = cv.mazeView;\nwindow.loadMaze = function(m) {\n\twindow.maze = cv.mazeView.maze = maze = m;\n\tm.mazeView = cv.mazeView;\n\tcv.mazeView.reloadAll();\n};\n\n$.notify.addStyle('plain', {\n\thtml: '<div><span data-notify-text/></div>',\n\tclasses: {\n\t\tbase: {\n\t\t\t'white-space': 'nowrap',\n\t\t\t'background-color': 'lightblue',\n\t\t\t'padding': '5px',\n\t\t\t'text-align': 'right',\n\t\t},\n\t\terror: {},\n\t\tsuccess: {},\n\t\tinfo: {},\n\t\twarning: {},\n\t},\n});\n$.notify.defaults({style: 'plain'});\n\nlet hammer = new Hammer.Manager($canvas[0], {\n\trecognizers: [\n\t\t[Hammer.Pan],\n\t\t[Hammer.Tap],\n\t\t[Hammer.Tap, { event: 'doubletap', taps: 2 }, ['tap']],\n\t\t[Hammer.Press],\n\t\t[Hammer.Pinch],\n\t]\n});\nlet lastPan;\nhammer.on('panstart panmove', function(e) {\n\tif (e.type === 'panstart') {\n\t\tlastPan = {x: 0, y: 0};\n\t}\n\tcv.freePan(e.deltaX - lastPan.x, e.deltaY - lastPan.y);\n\tlastPan.x = e.deltaX;\n\tlastPan.y = e.deltaY;\n});\nhammer.on('panend', function(e) {\n\tconsole.log('pan', cv.getVisibleRect());\n});\nlet scaleStartTileSize;\nhammer.on('pinchstart pinchmove pinchend', function(e) {\n\tif (e.type === 'pinchstart') {\n\t\tscaleStartTileSize = cv.tileSize;\n\t}\n\tcv.freeZoom(e.center, scaleStartTileSize * e.scale);\n});\nhammer.on('tap', function(e) {\n\tlet {x, y} = cv.getTileCoords(e.center);\n\tconsole.log(e.type, x, y);\n\tmaze.toggle(x, y, 'ground');\n});\nhammer.on('doubletap', function(e) {\n\tlet {x, y} = cv.getTileCoords(e.center);\n\tconsole.log(e.type, x, y);\n\tmaze.toggle(x, y, 'block');\n});\nhammer.on('press', function(e) {\n\tlet {x, y} = cv.getTileCoords(e.center);\n\tconsole.log(e.type, x, y);\n\tmaze.clear(x, y);\n});\n\n// TODO make directions invert user-configurable\nMousetrap.bind('up', function() { cv.panDown(); });\nMousetrap.bind('right', function() { cv.panLeft(); });\nMousetrap.bind('down', function() { cv.panUp(); });\nMousetrap.bind('left', function() { cv.panRight(); });\n\n// TODO make direction invert user-configurable\n$(window).on('mousewheel', function(e) {\n\tcv.freeZoom({x: e.clientX, y: e.clientY}, cv.tileSize * (e.deltaY > 0 ? 1.1 : 0.9));\n\tconsole.log('zoom', cv.tileSize);\n});\n\nfunction resizeCanvas() {\n\tvar w = $canvas.outerWidth(), h = $canvas.outerHeight(); // copy actual size\n\t$canvas.attr({width: w, height: h}); // set width and height to actual size\n\tcv.mazeView.refocus(cv.getVisibleRect());\n\tcv.requireRedraw();\n}\nresizeCanvas();\nvar resizeTimeout;\n$(window).on('resize', function() {\n\tif (resizeTimeout) {\n\t\tclearTimeout(resizeTimeout);\n\t}\n\tresizeTimeout = setTimeout(function() {\n\t\tresizeTimeout = null;\n\t\tresizeCanvas();\n\t}, 100);\n});\n\n\nconsole.log('icemaze loaded!');\n","import Dexie from 'dexie';\n\nexport const db = new Dexie('mazes');\ndb.version( 1 ).stores({\n\tcells: \"[maze+x+y], maze, ground, block\"\n});\ndb.open().catch(err => {\n\tconsole.error(\"Couldn't open database\", err);\n});\n\nexport class Maze {\n\tconstructor(saveName, width=100, height=100) {\n\t\tif (width <= 0 || height <= 0 || width%1 || height%1) {\n\t\t\tthrow \"width and height must be positive integers\";\n\t\t}\n\t\tthis.grid = [];\n\t\tthis.width = Math.round(width);\n\t\tthis.height = Math.round(height);\n\n\t\tif (saveName) {\n\t\t\tthis.saveName = saveName;\n\t\t\tthis._restoreMaze(saveName);\n\t\t}\n\t}\n\n\t_persist(x, y, cell) {\n\t\tif (!this.saveName) {\n\t\t\treturn;\n\t\t}\n\t\tcell.maze = this.saveName;\n\t\tcell.x = x;\n\t\tcell.y = y;\n\t\tdb.cells.put(cell);\n\t}\n\n\t_delete(cell) {\n\t\tif (!this.saveName) {\n\t\t\treturn;\n\t\t}\n\t\tdb.cells.delete([cell.maze, cell.x, cell.y]);\n\t}\n\n\t_restoreMaze(saveName) {\n\t\tlet grid = this.grid;\n\t\tlet cells = db.cells.where('maze').equals(saveName).each(cell => {\n\t\t\tlet row = grid[cell.y];\n\t\t\tif (!row) {\n\t\t\t\tgrid[cell.y] = row = [];\n\t\t\t\trow.cellCount = 0;\n\t\t\t}\n\t\t\tif (!row[cell.x]) {\n\t\t\t\trow.cellCount++;\n\t\t\t}\n\t\t\trow[cell.x] = cell;\n\t\t}).then(function() {\n\t\t\tconsole.log('Restored maze', saveName);\n\t\t\tif (this.mazeView) {\n\t\t\t\tthis.mazeView.reloadAll();\n\t\t\t}\n\t\t}.bind(this)).catch(err => {\n\t\t\tconsole.error('Failed to restore maze', err);\n\t\t});\n\t}\n\n\t_wrap(x, y) {\n\t\tif (x%1 || y%1) { throw \"x and y must be integers\"; }\n\t\tx = x < 0 ? this.width+(x%this.width) : x%this.width;\n\t\ty = y < 0 ? this.height+(y%this.height) : y%this.height;\n\t\treturn [x, y];\n\t}\n\n\tget(x, y, prop, create = false) {\n\t\t[x, y] = this._wrap(x, y);\n\t\tif (create) {\n\t\t\tlet created = false;\n\t\t\tlet row = this.grid[y];\n\t\t\tif (!row) {\n\t\t\t\tthis.grid[y] = row = [];\n\t\t\t\trow.cellCount = 0;\n\t\t\t}\n\t\t\tlet cell = row[x];\n\t\t\tif (cell) {\n\t\t\t\treturn prop ? cell[prop] : {cell};\n\t\t\t}\n\t\t\trow[x] = cell = {};\n\t\t\trow.cellCount++;\n\t\t\treturn prop ? cell[prop] : {cell, created: true};\n\t\t}\n\t\tlet row = this.grid[y] || [];\n\t\tlet cell = row[x], safeCell = cell || {};\n\t\treturn prop ? safeCell[prop] : {cell: safeCell, fake: !cell};\n\t}\n\n\ttoggle(x, y, prop, state) {\n\t\t[x, y] = this._wrap(x, y);\n\t\tlet r = this.get(x, y, null, true);\n\t\tr.cell[prop] = state === undefined ? !r.cell[prop] : state;\n\t\tthis._persist(x, y, r.cell);\n\t\tif (this.mazeView) {\n\t\t\tthis.mazeView.reload(x, y, r.cell);\n\t\t}\n\t\treturn r;\n\t}\n\n\tclear(x, y) {\n\t\t[x, y] = this._wrap(x, y);\n\t\tlet row = this.grid[y], cell = row ? row[x] : null;\n\t\tif (cell) {\n\t\t\tthis._delete(cell);\n\t\t\t// don't splice to delete because it shifts subsequent indices down\n\t\t\trow[x] = undefined;\n\t\t\trow.cellCount--;\n\t\t\tif (row.cellCount === 0) {\n\t\t\t\tthis.grid[y] = undefined;\n\t\t\t}\n\t\t\tif (this.mazeView) {\n\t\t\t\tthis.mazeView.reload(x, y, null);\n\t\t\t}\n\t\t\treturn true; // something got deleted\n\t\t}\n\t\treturn false; // nothing was there\n\t}\n}\n\nexport default Maze;\n","import Maze from './maze';\n\n// TODO make sparse\n\n// linked list sparse array of visible cells for drawing and panning\nexport default class MazeView {\n\tconstructor(maze, {x, y, w, h}) {\n\t\tmaze.mazeView = this; // backreference so maze can call up\n\t\tthis.maze = maze;\n\t\tthis.width = 1;\n\t\tthis.height = 1;\n\t\tthis.firstRow = {\n\t\t\ty: 0,\n\t\t\tnextRow: null,\n\t\t\tfirstCol: {\n\t\t\t\tx: 0,\n\t\t\t\tnextCol: null,\n\t\t\t\tcell: maze.get(0, 0).cell,\n\t\t\t},\n\t\t};\n\t\tthis.refocus({x, y, w, h});\n\t}\n\n\trefocus({x: newX, y: newY, w: newW, h: newH}) {\n\t\tif (newX === this.firstRow.firstCol.x && newY === this.firstRow.y &&\n\t\t\tnewW === this.width && newH === this.height) {\n\t\t\treturn;\n\t\t}\n\t\tif (newX%1 || newY%1) { throw \"x and y must be integers\"; }\n\t\tif (newW <= 0 || newH <= 0 || newW%1 || newH%1) { throw \"w and h must be positive integers\"; }\n\n\t\tlet oldX = this.firstRow.firstCol.x;\n\t\tlet oldW = this.width;\n\t\tlet oldY = this.firstRow.y;\n\t\tlet oldH = this.height;\n\n\t\tthis.width = newW;\n\t\tthis.height = newH;\n\n\t\tlet firstRow;\n\t\tif (newY >= oldY && newY < oldY + oldH) {\n\t\t\tfirstRow = this.firstRow; // grab existing first row\n\t\t\twhile (firstRow.y !== newY) firstRow = firstRow.nextRow; // drop rows below\n\t\t} else {\n\t\t\tfirstRow = {y: newY, firstCol: {x: newX}}; // create first row\n\t\t}\n\t\tlet row = firstRow;\n\t\tfor (let y = newY; y < newY + newH; y++) {\n\t\t\tlet firstCol;\n\t\t\tif (y >= oldY && y < oldY + oldH && newX >= oldX && newX < oldX + oldW) {\n\t\t\t\tfirstCol = row.firstCol; // grab existing first col\n\t\t\t\twhile (firstCol.x !== newX) firstCol = firstCol.nextCol; // drop cols left\n\t\t\t} else {\n\t\t\t\tfirstCol = {x: newX}; // create first col\n\t\t\t}\n\t\t\tlet col = firstCol;\n\t\t\tfor (let x = newX; x < newX + newW; x++) {\n\t\t\t\tif (!col.cell) {\n\t\t\t\t\tcol.cell = this.maze.get(x, y).cell;\n\t\t\t\t}\n\t\t\t\tif (x + 1 < newX + newW) {\n\t\t\t\t\tif (!col.nextCol) {\n\t\t\t\t\t\tif (row.firstCol.x === x + 1) {\n\t\t\t\t\t\t\tcol.nextCol = row.firstCol; // join cols right\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcol.nextCol = {x: x + 1}; // add col right\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcol = col.nextCol; // advance col\n\t\t\t\t} else {\n\t\t\t\t\tcol.nextCol = null; // last col\n\t\t\t\t\trow.firstCol = firstCol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y + 1 < newY + newH) {\n\t\t\t\tif (!row.nextRow) {\n\t\t\t\t\tif (this.firstRow.y === y + 1) {\n\t\t\t\t\t\trow.nextRow = this.firstRow; // join rows above\n\t\t\t\t\t} else {\n\t\t\t\t\t\trow.nextRow = {y: y + 1, firstCol: {x: newX}}; // add row above\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trow = row.nextRow; // advance row\n\t\t\t} else {\n\t\t\t\trow.nextRow = null; // last row\n\t\t\t\tthis.firstRow = firstRow;\n\t\t\t}\n\t\t}\n\t}\n\n\treloadAll() {\n\t\tlet row = this.firstRow;\n\t\twhile (row) {\n\t\t\tlet col = row.firstCol;\n\t\t\twhile (col) {\n\t\t\t\tcol.cell = this.maze.get(col.x, row.y).cell;\n\t\t\t\tcol = col.nextCol;\n\t\t\t}\n\t\t\trow = row.nextRow;\n\t\t}\n\t\tif (this.canvasView) {\n\t\t\tthis.canvasView.requireRedraw();\n\t\t}\n\t}\n\n\treload(x, y, cell) {\n\t\tcell = (cell === undefined ? this.maze.get(x, y).cell : cell);\n\t\t// transport x and y into nearest mazeview coordinates and repeat\n\t\tlet x0 = this.firstRow.firstCol.x, y0 = this.firstRow.y;\n\t\tlet mw = this.maze.width, mh = this.maze.height;\n\t\tlet xoff = x<0 ? mw+(x%mw) : x%mw;\n\t\tlet yoff = y<0 ? mh+(y%mh) : y%mh;\n\t\tlet x0off = x0<0 ? mw+(x0%mw) : x0%mw;\n\t\tlet y0off = y0<0 ? mh+(y0%mh) : y0%mh;\n\t\ty = y0 + (yoff - y0off);\n\t\tif (yoff < y0off) y += mh;\n\t\tlet row = this.firstRow;\n\t\tfor (; y < y0 + this.height; y += mh) {\n\t\t\twhile (row.y < y) row = row.nextRow;\n\t\t\tx = x0 + (xoff - x0off);\n\t\t\tif (xoff < x0off) x += mw;\n\t\t\tlet col = row.firstCol;\n\t\t\tfor (; x < x0 + this.width; x += mw) {\n\t\t\t\twhile (col.x < x) col = col.nextCol;\n\t\t\t\tconsole.debug('reload', x, y);\n\t\t\t\tcol.cell = cell;\n\t\t\t}\n\t\t}\n\t\tif (this.canvasView) {\n\t\t\tthis.canvasView.requireRedraw();\n\t\t}\n\t}\n\n\t// calls drawing function with (x, y, cell) for each visible cell with properties\n\tdrawTiles(drawingFunction) {\n\t\tlet row = this.firstRow;\n\t\tdo {\n\t\t\tlet col = row.firstCol;\n\t\t\tdo {\n\t\t\t\tif (col.cell) {\n\t\t\t\t\tdrawingFunction(col.x, row.y, col.cell);\n\t\t\t\t}\n\t\t\t} while ((col = col.nextCol));\n\t\t} while ((row = row.nextRow));\n\t}\n}\n","const width = 120;\nconst height = 50;\nconst x = width/2, y = height/2;\nconst font = '24px serif';\nconst debug = false;\n\nclass Logo {\n\n\tconstructor() {\n\t\tthis.canvas = document.createElement('canvas');\n\t\tthis.canvas.width = width;\n\t\tthis.canvas.height = height;\n\n\t\tlet c2d = this.canvas.getContext('2d');\n\t\tc2d.textBaseline = 'middle';\n\t\tc2d.textAlign = 'center';\n\t\tc2d.font = font;\n\n\t\tc2d.shadowColor = \"#0077FF\";\n\t\tc2d.shadowOffsetX = 0;\n\t\tc2d.shadowOffsetY = 0;\n\t\tc2d.shadowBlur = 7;\n\t\tc2d.strokeStyle = '#33FFFF';\n\t\tc2d.strokeText('IceMaze', x, y);\n\n\t\tc2d.fillStyle = 'white';\n\t\tc2d.fillText('IceMaze', x, y);\n\n\t\tif (debug) {\n\t\t\tc2d.strokeStyle = 'green';\n\t\t\tc2d.strokeRect(0, 0, width, height);\n\t\t}\n\t}\n\n\tdraw(targetCanvas) {\n\t\ttargetCanvas.getContext('2d').drawImage(this.canvas, 0, targetCanvas.height - height);\n\t}\n\n}\n\nexport default new Logo();\n","import $ from 'jquery';\nimport MazeView from './mazeview';\nimport logo from './logo';\n\nconst minTileSize = 9;\nconst maxTileSize = 61;\nconst frameMillis = 1000 / 60;\nconst zoomAnimMillis = 1000 / 4;\nconst panAnimPerTileMillis = 1000 / 10;\nconst debug = false;\n\nexport default class CanvasView {\n\tconstructor(canvas, maze) {\n\t\tthis.canvas = canvas;\n\t\tthis.c2d = canvas.getContext('2d');\n\t\tthis.targetX = 0; // current pan target center tile\n\t\tthis.targetY = 0;\n\t\tthis.panX = 0; // current actual pan point in tile coordinates\n\t\tthis.panY = 0;\n\t\tthis.tileSize = 21;\n\t\tthis.redrawRequired = false;\n\t\tthis.lastRedrawTime = 0;\n\t\tthis.preDrawCallbacks = [];\n\t\tthis.postDrawCallbacks = [];\n\t\tthis.mazeView = new MazeView(maze, this.getVisibleRect());\n\t\tthis.mazeView.canvasView = this; // backreference so mazeview can call up\n\t\tthis.requireRedraw();\n\t}\n\n\t// returns tile coordinates corresponding to given canvas coordinates\n\tgetTileCoords({x: canvasX, y: canvasY}) {\n\t\treturn {\n\t\t\tx: Math.round(((canvasX - this.canvas.width/2) + (this.panX*this.tileSize)) / this.tileSize),\n\t\t\ty: Math.round(((this.canvas.height/2 - canvasY) + (this.panY*this.tileSize)) / this.tileSize),\n\t\t};\n\t}\n\n\t// returns canvas coordinates of top-left corner of specified tile\n\tgetCanvasCoords({x: tileX, y: tileY}) {\n\t\treturn {\n\t\t\tx: (((tileX * this.tileSize) - (this.panX*this.tileSize)) + this.canvas.width/2) - this.tileSize/2,\n\t\t\ty: -(((tileY * this.tileSize) - (this.panY*this.tileSize)) - this.canvas.height/2) - this.tileSize/2,\n\t\t};\n\t}\n\n\t// returns the viewport rect {x, y, w, h} in tile coordinates\n\tgetVisibleRect() {\n\t\tlet bottomLeft = this.getTileCoords({x: 0, y: this.canvas.height});\n\t\treturn {\n\t\t\tx: bottomLeft.x,\n\t\t\ty: bottomLeft.y,\n\t\t\tw: Math.ceil(this.canvas.width / this.tileSize) + 1,\n\t\t\th: Math.ceil(this.canvas.height / this.tileSize) + 1,\n\t\t};\n\t}\n\n\tfillTile(point, fillStyle = 'blue') {\n\t\tlet {x, y} = this.getCanvasCoords(point);\n\t\tthis.c2d.fillStyle = fillStyle;\n\t\tthis.c2d.fillRect(x, y, this.tileSize, this.tileSize);\n\t}\n\n\tzoom(factor) {\n\t\tthis.zoomTo(this.tileSize * factor);\n\t}\n\n\tfreeZoom(center, targetTileSize) {\n\t\ttargetTileSize = Math.round(targetTileSize);\n\t\tif (targetTileSize % 2 === 0) {\n\t\t\t// scene is centered on tile center;\n\t\t\t// use odd number for target tile size so final view is pixel perfect\n\t\t\ttargetTileSize += 1;\n\t\t}\n\t\tif (targetTileSize < minTileSize) {\n\t\t\ttargetTileSize = minTileSize;\n\t\t} else if (targetTileSize > maxTileSize) {\n\t\t\ttargetTileSize = maxTileSize;\n\t\t}\n\n\t\t// update pan and target\n\t\tlet factor = (targetTileSize / this.tileSize) - 1;\n\t\tlet dx = ((center.x - this.canvas.width/2)/targetTileSize) * factor;\n\t\tlet dy = ((this.canvas.height/2 - center.y)/targetTileSize) * factor;\n\t\tthis.panX += dx;\n\t\tthis.panY += dy;\n\t\tthis.targetX += dx;\n\t\tthis.targetY += dy;\n\n\t\tthis.tileSize = targetTileSize;\n\t\tthis.mazeView.refocus(this.getVisibleRect());\n\t\tthis.requireRedraw();\n\t}\n\n\t// TODO replace zoomTo/panTo with unified centerOn\n\n\t// sets running zoom to new target\n\tzoomTo(targetTileSize, finishedCallback) {\n\t\ttargetTileSize = Math.round(targetTileSize);\n\t\tif (targetTileSize % 2 === 0) {\n\t\t\t// scene is centered on tile center;\n\t\t\t// use odd number for target tile size so final view is pixel perfect\n\t\t\ttargetTileSize += 1;\n\t\t}\n\t\tif (targetTileSize < minTileSize) {\n\t\t\ttargetTileSize = minTileSize;\n\t\t} else if (targetTileSize > maxTileSize) {\n\t\t\ttargetTileSize = maxTileSize;\n\t\t}\n\n\t\t// remove existing zoom step function\n\t\tthis.preDrawCallbacks = this.preDrawCallbacks.filter(function(fn) {\n\t\t\treturn !fn.zoomStepper;\n\t\t});\n\n\t\tif (targetTileSize === this.tileSize) {\n\t\t\tif (typeof finishedCallback === 'function') {\n\t\t\t\tfinishedCallback();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// build new step function\n\t\tlet initialTileSize = this.tileSize;\n\t\tlet difference = targetTileSize - initialTileSize;\n\t\tlet animStartMillis = (new Date()).getTime();\n\t\tlet stepFunction = (function() {\n\t\t\tvar percent = (this.lastRedrawTime - animStartMillis) / zoomAnimMillis;\n\t\t\tif (percent < 0) { percent = 0; }\n\t\t\telse if (percent > 1) { percent = 1; }\n\t\t\tthis.tileSize = initialTileSize + (percent * difference);\n\t\t\tthis.mazeView.refocus(this.getVisibleRect());\n\t\t\tif (percent < 1) {\n\t\t\t\tthis.requireRedraw(stepFunction);\n\t\t\t} else {\n\t\t\t\tconsole.log('tile size', this.tileSize);\n\t\t\t\tthis.zoomInProgress = false;\n\t\t\t\tthis.requireRedraw();\n\t\t\t\tif (typeof finishedCallback === 'function') {\n\t\t\t\t\tfinishedCallback();\n\t\t\t\t}\n\t\t\t}\n\t\t}).bind(this);\n\t\tstepFunction.zoomStepper = true;\n\t\tthis.requireRedraw(stepFunction);\n\t}\n\n\tpanUp(n = 1) {\n\t\tthis.panTo({y: this.targetY + Math.round(n)});\n\t}\n\n\tpanRight(n = 1) {\n\t\tthis.panTo({x: this.targetX + Math.round(n)});\n\t}\n\n\tpanDown(n = 1) {\n\t\tthis.panTo({y: this.targetY - Math.round(n)});\n\t}\n\n\tpanLeft(n = 1) {\n\t\tthis.panTo({x: this.targetX - Math.round(n)});\n\t}\n\n\tfreePan(canvasDiffX, canvasDiffY) {\n\t\tlet diffX = canvasDiffX / this.tileSize;\n\t\tlet diffY = canvasDiffY / this.tileSize;\n\t\tthis.panX -= diffX;\n\t\tthis.panY += diffY;\n\t\tthis.targetX -= diffX;\n\t\tthis.targetY += diffY;\n\t\tthis.mazeView.refocus(this.getVisibleRect());\n\t\tthis.requireRedraw();\n\t}\n\n\t// sets running pan to nearest point\n\tpanCenter() {\n\t\tthis.panTo({x: this.panX, y: this.panY});\n\t}\n\n\t// sets running pan to new target\n\tpanTo({x = this.targetX, y = this.targetY}, finishedCallback) {\n\t\tthis.targetX = Math.round(x);\n\t\tthis.targetY = Math.round(y);\n\n\t\t// remove existing panning step function\n\t\tthis.preDrawCallbacks = this.preDrawCallbacks.filter(function(fn) {\n\t\t\treturn !fn.panStepper;\n\t\t});\n\n\t\tif (this.targetX === this.panX && this.targetY === this.panY) {\n\t\t\tif (typeof finishedCallback === 'function') {\n\t\t\t\tfinishedCallback();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// build new step function\n\t\tlet initialX = this.panX, initialY = this.panY;\n\t\tlet diffX = this.targetX - initialX, diffY = this.targetY - initialY;\n\t\tlet hypotenuse = Math.sqrt(diffX*diffX + diffY*diffY);\n\t\tlet animMillis = hypotenuse * panAnimPerTileMillis;\n\t\tlet animStartMillis = (new Date()).getTime();\n\t\tlet stepFunction = (function() {\n\t\t\tvar percent = (this.lastRedrawTime - animStartMillis) / animMillis;\n\t\t\tif (percent < 0) {\n\t\t\t\tpercent = 0;\n\t\t\t}\n\t\t\tif (percent < 1) {\n\t\t\t\tthis.panX = initialX + (percent * diffX);\n\t\t\t\tthis.panY = initialY + (percent * diffY);\n\t\t\t\tthis.mazeView.refocus(this.getVisibleRect());\n\t\t\t\tthis.requireRedraw(stepFunction);\n\t\t\t} else {\n\t\t\t\tthis.panX = this.targetX;\n\t\t\t\tthis.panY = this.targetY;\n\t\t\t\tthis.mazeView.refocus(this.getVisibleRect());\n\t\t\t\tconsole.log('pan center', this.panX, this.panY);\n\t\t\t\tthis.requireRedraw();\n\t\t\t\tif (typeof finishedCallback === 'function') {\n\t\t\t\t\tfinishedCallback();\n\t\t\t\t}\n\t\t\t}\n\t\t}).bind(this);\n\t\tstepFunction.panStepper = true;\n\t\tthis.requireRedraw(stepFunction);\n\t}\n\n\trequireRedraw(preDrawCallback, postDrawCallback) {\n\t\tif (typeof preDrawCallback === 'function') {\n\t\t\tthis.preDrawCallbacks.push(preDrawCallback);\n\t\t}\n\t\tif (typeof postDrawCallback === 'function') {\n\t\t\tthis.postDrawCallbacks.push(postDrawCallback);\n\t\t}\n\t\tif (this.redrawRequired) {\n\t\t\t// redraw already pending\n\t\t\treturn;\n\t\t}\n\t\tthis.redrawRequired = true;\n\t\tif (window.requestAnimationFrame) {\n\t\t\twindow.requestAnimationFrame(this.redraw.bind(this));\n\t\t} else {\n\t\t\tlet nextFrame = frameMillis - ((new Date()).getTime() - this.lastRedrawTime);\n\t\t\twindow.setTimeout(this.redraw.bind(this), nextFrame > 0 ? nextFrame : 0);\n\t\t}\n\t}\n\n\tredraw() {\n\t\tthis.redrawRequired = false;\n\t\tthis.lastRedrawTime = (new Date()).getTime();\n\n\t\tlet preDrawCallbacks = this.preDrawCallbacks;\n\t\tthis.preDrawCallbacks = [];\n\t\tpreDrawCallbacks.forEach(function(cb){ cb(); });\n\n\t\tthis.c2d.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\t\tthis.drawGrid();\n\t\tthis.mazeView.drawTiles(function(x, y, cell) {\n\t\t\tif (cell.startTile) {\n\t\t\t\tthis.fillTile({x, y}, 'blue');\n\t\t\t} else if (cell.endTile) {\n\t\t\t\tthis.fillTile({x, y}, 'green');\n\t\t\t} else if (cell.block) {\n\t\t\t\tthis.fillTile({x, y}, 'black');\n\t\t\t} else if (cell.ground) {\n\t\t\t\tthis.fillTile({x, y}, 'brown');\n\t\t\t}\n\t\t}.bind(this));\n\t\tlogo.draw(this.canvas);\n\n\t\tlet postDrawCallbacks = this.postDrawCallbacks;\n\t\tthis.postDrawCallbacks = [];\n\t\tpostDrawCallbacks.forEach(function(cb){ cb(); });\n\t}\n\n\tdrawGrid() {\n\t\tlet w = this.canvas.width, h = this.canvas.height, tileSize = this.tileSize;\n\t\tlet c2d = this.c2d;\n\n\t\tif (debug) {\n\t\t\tc2d.lineWidth = 1;\n\t\t\tc2d.strokeStyle = 'green';\n\t\t\tc2d.strokeRect(0, 0, w, h);\n\t\t}\n\n\t\tc2d.beginPath();\n\t\tlet x = ((w-tileSize)/2)%tileSize - tileSize*(this.panX%1);\n\t\tfor (; x < w; x += tileSize) {\n\t\t\tc2d.moveTo(x, 0);\n\t\t\tc2d.lineTo(x, h);\n\t\t}\n\t\tlet y = ((h-tileSize)/2)%tileSize - tileSize*(1-(this.panY%1));\n\t\tfor (; y < h; y += tileSize) {\n\t\t\tc2d.moveTo(0, y);\n\t\t\tc2d.lineTo(w, y);\n\t\t}\n\t\tc2d.closePath();\n\t\tc2d.lineWidth = 1;\n\t\tc2d.strokeStyle = 'rgba(0,0,0,.2)';\n\t\tc2d.stroke();\n\t}\n}\n"],"names":["resizeCanvas","w","$canvas","outerWidth","h","outerHeight","attr","width","height","mazeView","refocus","cv","getVisibleRect","requireRedraw","db","Dexie","version","stores","open","catch","error","err","Maze","saveName","grid","Math","round","_restoreMaze","x","y","cell","this","maze","cells","put","delete","where","equals","each","row","cellCount","then","log","reloadAll","bind","prop","create","_wrap","created","safeCell","fake","state","r","get","undefined","_persist","reload","_delete","MazeView","firstRow","newX","newY","newW","newH","firstCol","oldX","oldW","oldY","oldH","nextRow","nextCol","col","canvasView","x0","y0","mw","mh","xoff","yoff","x0off","y0off","console","debug","drawingFunction","font","Logo","canvas","document","createElement","c2d","getContext","textBaseline","textAlign","shadowColor","shadowOffsetX","shadowOffsetY","shadowBlur","strokeStyle","strokeText","fillStyle","fillText","strokeRect","targetCanvas","drawImage","minTileSize","maxTileSize","frameMillis","zoomAnimMillis","panAnimPerTileMillis","CanvasView","targetX","targetY","panX","panY","tileSize","redrawRequired","lastRedrawTime","preDrawCallbacks","postDrawCallbacks","canvasX","canvasY","tileX","tileY","bottomLeft","getTileCoords","ceil","point","getCanvasCoords","fillRect","factor","zoomTo","center","targetTileSize","dx","dy","finishedCallback","filter","fn","zoomStepper","initialTileSize","difference","animStartMillis","Date","getTime","stepFunction","percent","zoomInProgress","n","panTo","canvasDiffX","canvasDiffY","diffX","diffY","panStepper","initialX","initialY","hypotenuse","sqrt","animMillis","preDrawCallback","postDrawCallback","push","window","requestAnimationFrame","redraw","nextFrame","setTimeout","forEach","cb","clearRect","drawGrid","drawTiles","startTile","fillTile","endTile","block","ground","draw","lineWidth","beginPath","moveTo","lineTo","closePath","stroke","$","mazeDb","loadMaze","m","notify","addStyle","defaults","style","hammer","Hammer","Manager","Pan","Tap","event","taps","Press","Pinch","lastPan","on","e","type","freePan","deltaX","deltaY","scaleStartTileSize","freeZoom","scale","toggle","clear","Mousetrap","panDown","panLeft","panUp","panRight","clientX","clientY","resizeTimeout"],"mappings":"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"}