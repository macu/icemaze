{"version":3,"file":"compiled.js","sources":["app.js","maze.js","mazeview.js","logo.js","canvasview.js"],"sourcesContent":["import $ from 'jquery';\nimport Hammer from 'hammerjs';\nimport CanvasView from './canvasview';\nimport Maze from './maze';\n\nlet $canvas = $('canvas'), canvas = $canvas[0];\nlet maze = new Maze(100, 100, 'a');\n// maze.randomScatter('block');\nlet cv = new CanvasView(canvas, maze);\n\n// for debugging\nwindow.maze = maze;\nwindow.canvasView = cv;\nwindow.mazeView = cv.mazeView;\n\n$.notify.addStyle('plain', {\n\thtml: '<div><span data-notify-text/></div>',\n\tclasses: {\n\t\tbase: {\n\t\t\t'white-space': 'nowrap',\n\t\t\t'background-color': 'lightblue',\n\t\t\t'padding': '5px',\n\t\t\t'text-align': 'right',\n\t\t},\n\t\terror: {},\n\t\tsuccess: {},\n\t\tinfo: {},\n\t\twarning: {},\n\t},\n});\n$.notify.defaults({style: 'plain'});\n\nlet hammer = new Hammer.Manager($canvas[0], {\n\trecognizers: [\n\t\t[Hammer.Pan],\n\t\t[Hammer.Tap],\n\t\t[Hammer.Tap, { event: 'doubletap', taps: 2 }, ['tap']],\n\t\t[Hammer.Press],\n\t\t[Hammer.Pinch],\n\t]\n});\nlet lastPan;\nhammer.on('panstart panmove', function(e) {\n\tif (e.type === 'panstart') {\n\t\tlastPan = {x: 0, y: 0};\n\t}\n\tcv.freePan(e.deltaX - lastPan.x, e.deltaY - lastPan.y);\n\tlastPan.x = e.deltaX;\n\tlastPan.y = e.deltaY;\n});\nhammer.on('panend', function(e) {\n\tconsole.log('pan', cv.getVisibleRect());\n});\nlet scaleStartTileSize;\nhammer.on('pinchstart pinchmove pinchend', function(e) {\n\tif (e.type === 'pinchstart') {\n\t\tscaleStartTileSize = cv.tileSize;\n\t}\n\tcv.freeZoom(e.center, scaleStartTileSize * e.scale);\n});\nhammer.on('tap', function(e) {\n\tlet {x, y} = cv.getTileCoords(e.center);\n\tconsole.log(e.type, x, y);\n\tcv.mazeView.toggle(x, y, 'ground');\n\tcv.requireRedraw();\n});\nhammer.on('doubletap', function(e) {\n\tlet {x, y} = cv.getTileCoords(e.center);\n\tconsole.log(e.type, x, y);\n\tcv.mazeView.toggle(x, y, 'block');\n\tcv.requireRedraw();\n});\nhammer.on('press', function(e) {\n\tlet {x, y} = cv.getTileCoords(e.center);\n\tconsole.log(e.type, x, y);\n\tcv.mazeView.clear(x, y);\n\tcv.requireRedraw();\n});\n\n// TODO make directions invert user-configurable\nMousetrap.bind('up', function() { cv.panDown(); });\nMousetrap.bind('right', function() { cv.panLeft(); });\nMousetrap.bind('down', function() { cv.panUp(); });\nMousetrap.bind('left', function() { cv.panRight(); });\n\n// TODO make direction invert user-configurable\n$(window).on('mousewheel', function(e) {\n\tcv.freeZoom({x: e.clientX, y: e.clientY}, cv.tileSize * (e.deltaY > 0 ? 1.1 : 0.9));\n\tconsole.log('zoom', cv.tileSize);\n});\n\nfunction resizeCanvas() {\n\tvar w = $canvas.outerWidth(), h = $canvas.outerHeight(); // copy actual size\n\t$canvas.attr({width: w, height: h}); // set width and height to actual size\n\tcv.mazeView.refocus(cv.getVisibleRect());\n\tcv.requireRedraw();\n}\nresizeCanvas();\nvar resizeTimeout;\n$(window).on('resize', function() {\n\tif (resizeTimeout) {\n\t\tclearTimeout(resizeTimeout);\n\t}\n\tresizeTimeout = setTimeout(function() {\n\t\tresizeTimeout = null;\n\t\tresizeCanvas();\n\t}, 100);\n});\n\n\nconsole.log('icemaze loaded!');\n","import Dexie from 'dexie';\n\nconst db = new Dexie('mazes');\ndb.version(1).stores({\n\tcells: \"[maze+x+y], maze, ground, block\"\n});\ndb.open().catch(err => {\n\tconsole.error(\"Couldn't open database\", err);\n});\n\nexport default class Maze {\n\n\tconstructor(width, height, saveName) {\n\t\tthis.grid = [];\n\t\tthis.width = Math.round(width);\n\t\tthis.height = Math.round(height);\n\n\t\tif (saveName) {\n\t\t\tthis.saveName = saveName;\n\t\t\tthis._restoreMaze(saveName);\n\t\t}\n\t}\n\n\t_save(x, y, cell) {\n\t\tif (!this.saveName) {\n\t\t\treturn;\n\t\t}\n\t\tcell.maze = this.saveName;\n\t\tcell.x = x < 0 ? this.width+(x%this.width) : x%this.width;\n\t\tcell.y = y < 0 ? this.height+(y%this.height) : y%this.height;\n\t\tdb.cells.put(cell);\n\t}\n\n\t_delete(cell) {\n\t\tif (!this.saveName) {\n\t\t\treturn;\n\t\t}\n\t\tdb.cells.delete([cell.maze, cell.x, cell.y]);\n\t}\n\n\t_restoreMaze(saveName, restoredCallback) {\n\t\tlet grid = this.grid;\n\t\tlet cells = db.cells.where('maze').equals(saveName).each(cell => {\n\t\t\tlet row = grid[cell.y];\n\t\t\tif (!row) {\n\t\t\t\tgrid[cell.y] = row = [];\n\t\t\t\trow.cellCount = 0;\n\t\t\t}\n\t\t\tif (!row[cell.x]) {\n\t\t\t\trow.cellCount++;\n\t\t\t}\n\t\t\trow[cell.x] = cell;\n\t\t}).then(function() {\n\t\t\tif (this.mazeView) this.mazeView.reload();\n\t\t}.bind(this)).catch(err => {\n\t\t\tconsole.error('Failed to restore maze', err);\n\t\t});\n\t}\n\n\tget(x, y, prop, create = false) {\n\t\tx = x < 0 ? this.width+(x%this.width) : x%this.width;\n\t\ty = y < 0 ? this.height+(y%this.height) : y%this.height;\n\t\tif (create) {\n\t\t\tlet created = false;\n\t\t\tlet row = this.grid[y];\n\t\t\tif (!row) {\n\t\t\t\tthis.grid[y] = row = [];\n\t\t\t\trow.cellCount = 0;\n\t\t\t}\n\t\t\tlet cell = row[x];\n\t\t\tif (cell) {\n\t\t\t\treturn prop ? cell[prop] : {cell};\n\t\t\t}\n\t\t\trow[x] = cell = {};\n\t\t\trow.cellCount++;\n\t\t\treturn prop ? cell[prop] : {cell, created: true};\n\t\t}\n\t\tlet row = this.grid[y] || [];\n\t\tlet cell = row[x], safeCell = cell || {};\n\t\treturn prop ? safeCell[prop] : {cell: safeCell, fake: !cell};\n\t}\n\n\ttoggle(x, y, prop, state) {\n\t\tlet r = this.get(x, y, null, true);\n\t\tr.cell[prop] = state === undefined ? !r.cell[prop] : state;\n\t\tthis._save(x, y, r.cell);\n\t\treturn r;\n\t}\n\n\tclear(x, y) {\n\t\tx = x < 0 ? this.width+(x%this.width) : x%this.width;\n\t\ty = y < 0 ? this.height+(y%this.height) : y%this.height;\n\t\tlet row = this.grid[y], cell = row ? row[x] : null;\n\t\tif (cell) {\n\t\t\tthis._delete(cell);\n\t\t\tif (x >= 0) {\n\t\t\t\trow.splice(x, 1);\n\t\t\t} else {\n\t\t\t\trow[x] = undefined;\n\t\t\t}\n\t\t\trow.cellCount--;\n\t\t\tif (row.cellCount === 0) {\n\t\t\t\tif (y >= 0) {\n\t\t\t\t\tthis.grid.splice(y, 1);\n\t\t\t\t} else {\n\t\t\t\t\tthis.grid[y] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true; // something got deleted\n\t\t}\n\t\treturn false; // nothing was there\n\t}\n\n\t// randomCover(prop) {\n\t// \t// TODO ensure prop is applied to at least one cell in every row and column\n\t//\n\t// \tlet arr = new Array(this.width);\n\t//\n\t// \tlet x = 0, y = 0;\n\t// \twhile (x < this.width && y < this.height) {\n\t// \t\tif (x < this.width && y < this.height) {\n\t//\n\t// \t\t}\n\t// \t}\n\t//\n\t// }\n\n}\n","import Maze from './maze';\n\n// TODO make sparse\n\n// linked list sparse array of visible cells for drawing and panning\nexport default class MazeView {\n\tconstructor(maze, {x, y, w, h}) {\n\t\tif (x%1) { throw \"x must be an integer\"; }\n\t\tif (y%1) { throw \"y must be an integer\"; }\n\t\tif (w <= 0 || w%1) { throw \"width must be an integer > 0\"; }\n\t\tif (h <= 0 || h%1) { throw \"height must be an integer > 0\"; }\n\n\t\tmaze.mazeView = this; // backreference hack so maze can call up\n\n\t\tthis.maze = maze;\n\t\tthis.width = 1;\n\t\tthis.height = 1;\n\t\tthis.firstRow = {\n\t\t\ty: 0,\n\t\t\tnextRow: null,\n\t\t\tfirstCol: {\n\t\t\t\tx: 0,\n\t\t\t\tnextCol: null,\n\t\t\t\tcell: maze.get(0, 0).cell,\n\t\t\t},\n\t\t};\n\n\t\tthis.refocus({x, y, w, h});\n\t}\n\n\trefocus({x: newX, y: newY, w: newW, h: newH}) {\n\t\tif (newX === this.firstRow.firstCol.x && newY === this.firstRow.y &&\n\t\t\tnewW === this.width && newH === this.height) {\n\t\t\treturn;\n\t\t}\n\t\tif (newX%1 || newY%1) { throw \"x and y must be integers\"; }\n\t\tif (newW <= 0 || newH <= 0 || newW%1 || newH%1) { throw \"w and h must be integers > 0\"; }\n\n\t\tlet oldX = this.firstRow.firstCol.x;\n\t\tlet oldW = this.width;\n\t\tlet oldY = this.firstRow.y;\n\t\tlet oldH = this.height;\n\n\t\tthis.width = newW;\n\t\tthis.height = newH;\n\n\t\tlet firstRow;\n\t\tif (newY >= oldY && newY < oldY + oldH) {\n\t\t\tfirstRow = this.firstRow; // grab existing first row\n\t\t\twhile (firstRow.y !== newY) firstRow = firstRow.nextRow; // drop rows below\n\t\t} else {\n\t\t\tfirstRow = {y: newY, firstCol: {x: newX}}; // create first row\n\t\t}\n\t\tlet row = firstRow;\n\t\tfor (let y = newY; y < newY + newH; y++) {\n\t\t\tlet firstCol;\n\t\t\tif (y >= oldY && y < oldY + oldH && newX >= oldX && newX < oldX + oldW) {\n\t\t\t\tfirstCol = row.firstCol; // grab existing first col\n\t\t\t\twhile (firstCol.x !== newX) firstCol = firstCol.nextCol; // drop cols left\n\t\t\t} else {\n\t\t\t\tfirstCol = {x: newX}; // create first col\n\t\t\t}\n\t\t\tlet col = firstCol;\n\t\t\tfor (let x = newX; x < newX + newW; x++) {\n\t\t\t\tif (!col.cell) {\n\t\t\t\t\tcol.cell = this.maze.get(x, y).cell;\n\t\t\t\t}\n\t\t\t\tif (x + 1 < newX + newW) {\n\t\t\t\t\tif (!col.nextCol) {\n\t\t\t\t\t\tif (row.firstCol.x === x + 1) {\n\t\t\t\t\t\t\tcol.nextCol = row.firstCol; // join cols right\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcol.nextCol = {x: x + 1}; // add col right\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcol = col.nextCol; // advance col\n\t\t\t\t} else {\n\t\t\t\t\tcol.nextCol = null; // last col\n\t\t\t\t\trow.firstCol = firstCol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y + 1 < newY + newH) {\n\t\t\t\tif (!row.nextRow) {\n\t\t\t\t\tif (this.firstRow.y === y + 1) {\n\t\t\t\t\t\trow.nextRow = this.firstRow; // join rows above\n\t\t\t\t\t} else {\n\t\t\t\t\t\trow.nextRow = {y: y + 1, firstCol: {x: newX}}; // add row above\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trow = row.nextRow; // advance row\n\t\t\t} else {\n\t\t\t\trow.nextRow = null; // last row\n\t\t\t\tthis.firstRow = firstRow;\n\t\t\t}\n\t\t}\n\t}\n\n\treload() {\n\t\tlet row = this.firstRow;\n\t\twhile (row) {\n\t\t\tlet col = row.firstCol;\n\t\t\twhile (col) {\n\t\t\t\tcol.cell = this.maze.get(col.x, row.y).cell;\n\t\t\t\tcol = col.nextCol;\n\t\t\t}\n\t\t\trow = row.nextRow;\n\t\t}\n\t\tif (this.canvasView) this.canvasView.requireRedraw();\n\t}\n\n\tget(x, y, prop) {\n\t\treturn maze.get(x, y, prop);\n\t}\n\n\tgetCol(x, y) {\n\t\tlet row = this.firstRow;\n\t\twhile (row.y !== y) row = row.nextRow;\n\t\tlet col = row.firstCol;\n\t\twhile (col.x !== x) col = col.nextCol;\n\t\treturn col;\n\t}\n\n\ttoggle(x, y, prop, state) {\n\t\tlet r = this.maze.toggle(x, y, prop, state);\n\t\tif (r.created) {\n\t\t\tthis.getCol(x, y).cell = r.cell;\n\t\t}\n\t\treturn r;\n\t}\n\n\tclear(x, y) {\n\t\tif (this.maze.clear(x, y)) {\n\t\t\tthis.getCol(x, y).cell = null;\n\t\t}\n\t}\n\n\t// calls drawing function with (x, y, cell) for each visible cell with properties\n\tdrawTiles(drawingFunction) {\n\t\tlet row = this.firstRow;\n\t\tdo {\n\t\t\tlet col = row.firstCol;\n\t\t\tdo {\n\t\t\t\tif (col.cell) {\n\t\t\t\t\tdrawingFunction(col.x, row.y, col.cell);\n\t\t\t\t}\n\t\t\t} while ((col = col.nextCol));\n\t\t} while ((row = row.nextRow));\n\t}\n}\n","const width = 120;\nconst height = 50;\nconst x = width/2, y = height/2;\nconst font = '24px serif';\nconst debug = false;\n\nclass Logo {\n\n\tconstructor() {\n\t\tthis.canvas = document.createElement('canvas');\n\t\tthis.canvas.width = width;\n\t\tthis.canvas.height = height;\n\n\t\tlet c2d = this.canvas.getContext('2d');\n\t\tc2d.textBaseline = 'middle';\n\t\tc2d.textAlign = 'center';\n\t\tc2d.font = font;\n\n\t\tc2d.shadowColor = \"#0077FF\";\n\t\tc2d.shadowOffsetX = 0;\n\t\tc2d.shadowOffsetY = 0;\n\t\tc2d.shadowBlur = 7;\n\t\tc2d.strokeStyle = '#33FFFF';\n\t\tc2d.strokeText('IceMaze', x, y);\n\n\t\tc2d.fillStyle = 'white';\n\t\tc2d.fillText('IceMaze', x, y);\n\n\t\tif (debug) {\n\t\t\tc2d.strokeStyle = 'green';\n\t\t\tc2d.strokeRect(0, 0, width, height);\n\t\t}\n\t}\n\n\tdraw(targetCanvas) {\n\t\ttargetCanvas.getContext('2d').drawImage(this.canvas, 0, targetCanvas.height - height);\n\t}\n\n}\n\nexport default new Logo();\n","import $ from 'jquery';\nimport MazeView from './mazeview';\nimport logo from './logo';\n\nconst minTileSize = 9;\nconst maxTileSize = 61;\nconst frameMillis = 1000 / 60;\nconst zoomAnimMillis = 1000 / 4;\nconst panAnimPerTileMillis = 1000 / 10;\nconst debug = false;\n\nexport default class CanvasView {\n\tconstructor(canvas, maze) {\n\t\tthis.canvas = canvas;\n\t\tthis.c2d = canvas.getContext('2d');\n\t\tthis.targetX = 0; // current pan target center tile\n\t\tthis.targetY = 0;\n\t\tthis.panX = 0; // current actual pan point in tile coordinates\n\t\tthis.panY = 0;\n\t\tthis.tileSize = 21;\n\t\tthis.redrawRequired = false;\n\t\tthis.lastRedrawTime = 0;\n\t\tthis.preDrawCallbacks = [];\n\t\tthis.postDrawCallbacks = [];\n\t\tthis.mazeView = new MazeView(maze, this.getVisibleRect());\n\t\tthis.mazeView.canvasView = this; // backreference hack so mazeview can call up\n\t\tthis.requireRedraw();\n\t}\n\n\t// returns tile coordinates corresponding to given canvas coordinates\n\tgetTileCoords({x: canvasX, y: canvasY}) {\n\t\treturn {\n\t\t\tx: Math.round(((canvasX - this.canvas.width/2) + (this.panX*this.tileSize)) / this.tileSize),\n\t\t\ty: Math.round(((this.canvas.height/2 - canvasY) + (this.panY*this.tileSize)) / this.tileSize),\n\t\t};\n\t}\n\n\t// returns canvas coordinates of top-left corner of specified tile\n\tgetCanvasCoords({x: tileX, y: tileY}) {\n\t\treturn {\n\t\t\tx: (((tileX * this.tileSize) - (this.panX*this.tileSize)) + this.canvas.width/2) - this.tileSize/2,\n\t\t\ty: -(((tileY * this.tileSize) - (this.panY*this.tileSize)) - this.canvas.height/2) - this.tileSize/2,\n\t\t};\n\t}\n\n\t// returns the viewport rect {x, y, w, h} in tile coordinates\n\tgetVisibleRect() {\n\t\tlet bottomLeft = this.getTileCoords({x: 0, y: this.canvas.height});\n\t\treturn {\n\t\t\tx: bottomLeft.x,\n\t\t\ty: bottomLeft.y,\n\t\t\tw: Math.ceil(this.canvas.width / this.tileSize) + 1,\n\t\t\th: Math.ceil(this.canvas.height / this.tileSize) + 1,\n\t\t};\n\t}\n\n\tfillTile(point, fillStyle = 'blue') {\n\t\tlet {x, y} = this.getCanvasCoords(point);\n\t\tthis.c2d.fillStyle = fillStyle;\n\t\tthis.c2d.fillRect(x, y, this.tileSize, this.tileSize);\n\t}\n\n\tzoom(factor) {\n\t\tthis.zoomTo(this.tileSize * factor);\n\t}\n\n\tfreeZoom(center, targetTileSize) {\n\t\ttargetTileSize = Math.round(targetTileSize);\n\t\tif (targetTileSize % 2 === 0) {\n\t\t\t// scene is centered on tile center;\n\t\t\t// use odd number for target tile size so final view is pixel perfect\n\t\t\ttargetTileSize += 1;\n\t\t}\n\t\tif (targetTileSize < minTileSize) {\n\t\t\ttargetTileSize = minTileSize;\n\t\t} else if (targetTileSize > maxTileSize) {\n\t\t\ttargetTileSize = maxTileSize;\n\t\t}\n\n\t\t// update pan and target\n\t\tlet factor = (targetTileSize / this.tileSize) - 1;\n\t\tlet dx = ((center.x - this.canvas.width/2)/targetTileSize) * factor;\n\t\tlet dy = ((this.canvas.height/2 - center.y)/targetTileSize) * factor;\n\t\tthis.panX += dx;\n\t\tthis.panY += dy;\n\t\tthis.targetX += dx;\n\t\tthis.targetY += dy;\n\n\t\tthis.tileSize = targetTileSize;\n\t\tthis.mazeView.refocus(this.getVisibleRect());\n\t\tthis.requireRedraw();\n\t}\n\n\t// TODO replace zoomTo/panTo with unified centerOn\n\n\t// sets running zoom to new target\n\tzoomTo(targetTileSize, finishedCallback) {\n\t\ttargetTileSize = Math.round(targetTileSize);\n\t\tif (targetTileSize % 2 === 0) {\n\t\t\t// scene is centered on tile center;\n\t\t\t// use odd number for target tile size so final view is pixel perfect\n\t\t\ttargetTileSize += 1;\n\t\t}\n\t\tif (targetTileSize < minTileSize) {\n\t\t\ttargetTileSize = minTileSize;\n\t\t} else if (targetTileSize > maxTileSize) {\n\t\t\ttargetTileSize = maxTileSize;\n\t\t}\n\n\t\t// remove existing zoom step function\n\t\tthis.preDrawCallbacks = this.preDrawCallbacks.filter(function(fn) {\n\t\t\treturn !fn.zoomStepper;\n\t\t});\n\n\t\tif (targetTileSize === this.tileSize) {\n\t\t\tif (typeof finishedCallback === 'function') {\n\t\t\t\tfinishedCallback();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// build new step function\n\t\tlet initialTileSize = this.tileSize;\n\t\tlet difference = targetTileSize - initialTileSize;\n\t\tlet animStartMillis = (new Date()).getTime();\n\t\tlet stepFunction = (function() {\n\t\t\tvar percent = (this.lastRedrawTime - animStartMillis) / zoomAnimMillis;\n\t\t\tif (percent < 0) { percent = 0; }\n\t\t\telse if (percent > 1) { percent = 1; }\n\t\t\tthis.tileSize = initialTileSize + (percent * difference);\n\t\t\tthis.mazeView.refocus(this.getVisibleRect());\n\t\t\tif (percent < 1) {\n\t\t\t\tthis.requireRedraw(stepFunction);\n\t\t\t} else {\n\t\t\t\tconsole.log('tile size', this.tileSize);\n\t\t\t\tthis.zoomInProgress = false;\n\t\t\t\tthis.requireRedraw();\n\t\t\t\tif (typeof finishedCallback === 'function') {\n\t\t\t\t\tfinishedCallback();\n\t\t\t\t}\n\t\t\t}\n\t\t}).bind(this);\n\t\tstepFunction.zoomStepper = true;\n\t\tthis.requireRedraw(stepFunction);\n\t}\n\n\tpanUp(n = 1) {\n\t\tthis.panTo({y: this.targetY + Math.round(n)});\n\t}\n\n\tpanRight(n = 1) {\n\t\tthis.panTo({x: this.targetX + Math.round(n)});\n\t}\n\n\tpanDown(n = 1) {\n\t\tthis.panTo({y: this.targetY - Math.round(n)});\n\t}\n\n\tpanLeft(n = 1) {\n\t\tthis.panTo({x: this.targetX - Math.round(n)});\n\t}\n\n\tfreePan(canvasDiffX, canvasDiffY) {\n\t\tlet diffX = canvasDiffX / this.tileSize;\n\t\tlet diffY = canvasDiffY / this.tileSize;\n\t\tthis.panX -= diffX;\n\t\tthis.panY += diffY;\n\t\tthis.targetX -= diffX;\n\t\tthis.targetY += diffY;\n\t\tthis.mazeView.refocus(this.getVisibleRect());\n\t\tthis.requireRedraw();\n\t}\n\n\t// sets running pan to nearest point\n\tpanCenter() {\n\t\tthis.panTo({x: this.panX, y: this.panY});\n\t}\n\n\t// sets running pan to new target\n\tpanTo({x = this.targetX, y = this.targetY}, finishedCallback) {\n\t\tthis.targetX = Math.round(x);\n\t\tthis.targetY = Math.round(y);\n\n\t\t// remove existing panning step function\n\t\tthis.preDrawCallbacks = this.preDrawCallbacks.filter(function(fn) {\n\t\t\treturn !fn.panStepper;\n\t\t});\n\n\t\tif (this.targetX === this.panX && this.targetY === this.panY) {\n\t\t\tif (typeof finishedCallback === 'function') {\n\t\t\t\tfinishedCallback();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// build new step function\n\t\tlet initialX = this.panX, initialY = this.panY;\n\t\tlet diffX = this.targetX - initialX, diffY = this.targetY - initialY;\n\t\tlet hypotenuse = Math.sqrt(diffX*diffX + diffY*diffY);\n\t\tlet animMillis = hypotenuse * panAnimPerTileMillis;\n\t\tlet animStartMillis = (new Date()).getTime();\n\t\tlet stepFunction = (function() {\n\t\t\tvar percent = (this.lastRedrawTime - animStartMillis) / animMillis;\n\t\t\tif (percent < 0) {\n\t\t\t\tpercent = 0;\n\t\t\t}\n\t\t\tif (percent < 1) {\n\t\t\t\tthis.panX = initialX + (percent * diffX);\n\t\t\t\tthis.panY = initialY + (percent * diffY);\n\t\t\t\tthis.mazeView.refocus(this.getVisibleRect());\n\t\t\t\tthis.requireRedraw(stepFunction);\n\t\t\t} else {\n\t\t\t\tthis.panX = this.targetX;\n\t\t\t\tthis.panY = this.targetY;\n\t\t\t\tthis.mazeView.refocus(this.getVisibleRect());\n\t\t\t\tconsole.log('pan center', this.panX, this.panY);\n\t\t\t\tthis.requireRedraw();\n\t\t\t\tif (typeof finishedCallback === 'function') {\n\t\t\t\t\tfinishedCallback();\n\t\t\t\t}\n\t\t\t}\n\t\t}).bind(this);\n\t\tstepFunction.panStepper = true;\n\t\tthis.requireRedraw(stepFunction);\n\t}\n\n\trequireRedraw(preDrawCallback, postDrawCallback) {\n\t\tif (typeof preDrawCallback === 'function') {\n\t\t\tthis.preDrawCallbacks.push(preDrawCallback);\n\t\t}\n\t\tif (typeof postDrawCallback === 'function') {\n\t\t\tthis.postDrawCallbacks.push(postDrawCallback);\n\t\t}\n\t\tif (this.redrawRequired) {\n\t\t\t// redraw already pending\n\t\t\treturn;\n\t\t}\n\t\tthis.redrawRequired = true;\n\t\tif (window.requestAnimationFrame) {\n\t\t\twindow.requestAnimationFrame(this.redraw.bind(this));\n\t\t} else {\n\t\t\tlet nextFrame = frameMillis - ((new Date()).getTime() - this.lastRedrawTime);\n\t\t\twindow.setTimeout(this.redraw.bind(this), nextFrame > 0 ? nextFrame : 0);\n\t\t}\n\t}\n\n\tredraw() {\n\t\tthis.redrawRequired = false;\n\t\tthis.lastRedrawTime = (new Date()).getTime();\n\n\t\tlet preDrawCallbacks = this.preDrawCallbacks;\n\t\tthis.preDrawCallbacks = [];\n\t\tpreDrawCallbacks.forEach(function(cb){ cb(); });\n\n\t\tthis.c2d.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\t\tthis.drawGrid();\n\t\tthis.mazeView.drawTiles(function(x, y, cell) {\n\t\t\tif (cell.startTile) {\n\t\t\t\tthis.fillTile({x, y}, 'blue');\n\t\t\t} else if (cell.endTile) {\n\t\t\t\tthis.fillTile({x, y}, 'green');\n\t\t\t} else if (cell.block) {\n\t\t\t\tthis.fillTile({x, y}, 'black');\n\t\t\t} else if (cell.ground) {\n\t\t\t\tthis.fillTile({x, y}, 'brown');\n\t\t\t}\n\t\t}.bind(this));\n\t\tlogo.draw(this.canvas);\n\n\t\tlet postDrawCallbacks = this.postDrawCallbacks;\n\t\tthis.postDrawCallbacks = [];\n\t\tpostDrawCallbacks.forEach(function(cb){ cb(); });\n\t}\n\n\tdrawGrid() {\n\t\tlet w = this.canvas.width, h = this.canvas.height, tileSize = this.tileSize;\n\t\tlet c2d = this.c2d;\n\n\t\tif (debug) {\n\t\t\tc2d.lineWidth = 1;\n\t\t\tc2d.strokeStyle = 'green';\n\t\t\tc2d.strokeRect(0, 0, w, h);\n\t\t}\n\n\t\tc2d.beginPath();\n\t\tlet x = ((w-tileSize)/2)%tileSize - tileSize*(this.panX%1);\n\t\tfor (; x < w; x += tileSize) {\n\t\t\tc2d.moveTo(x, 0);\n\t\t\tc2d.lineTo(x, h);\n\t\t}\n\t\tlet y = ((h-tileSize)/2)%tileSize - tileSize*(1-(this.panY%1));\n\t\tfor (; y < h; y += tileSize) {\n\t\t\tc2d.moveTo(0, y);\n\t\t\tc2d.lineTo(w, y);\n\t\t}\n\t\tc2d.closePath();\n\t\tc2d.lineWidth = 1;\n\t\tc2d.strokeStyle = 'rgba(0,0,0,.2)';\n\t\tc2d.stroke();\n\t}\n}\n"],"names":["resizeCanvas","w","$canvas","outerWidth","h","outerHeight","attr","width","height","mazeView","refocus","cv","getVisibleRect","requireRedraw","db","Dexie","version","stores","open","catch","error","err","Maze","saveName","grid","Math","round","_restoreMaze","x","y","cell","this","maze","cells","put","delete","restoredCallback","where","equals","each","row","cellCount","then","reload","bind","prop","create","created","safeCell","fake","state","r","get","undefined","_save","_delete","splice","MazeView","firstRow","newX","newY","newW","newH","firstCol","oldX","oldW","oldY","oldH","nextRow","nextCol","col","canvasView","toggle","getCol","clear","drawingFunction","font","debug","Logo","canvas","document","createElement","c2d","getContext","textBaseline","textAlign","shadowColor","shadowOffsetX","shadowOffsetY","shadowBlur","strokeStyle","strokeText","fillStyle","fillText","strokeRect","targetCanvas","drawImage","minTileSize","maxTileSize","frameMillis","zoomAnimMillis","panAnimPerTileMillis","CanvasView","targetX","targetY","panX","panY","tileSize","redrawRequired","lastRedrawTime","preDrawCallbacks","postDrawCallbacks","canvasX","canvasY","tileX","tileY","bottomLeft","getTileCoords","ceil","point","getCanvasCoords","fillRect","factor","zoomTo","center","targetTileSize","dx","dy","finishedCallback","filter","fn","zoomStepper","initialTileSize","difference","animStartMillis","Date","getTime","stepFunction","percent","log","zoomInProgress","n","panTo","canvasDiffX","canvasDiffY","diffX","diffY","panStepper","initialX","initialY","hypotenuse","sqrt","animMillis","preDrawCallback","postDrawCallback","push","window","requestAnimationFrame","redraw","nextFrame","setTimeout","forEach","cb","clearRect","drawGrid","drawTiles","startTile","fillTile","endTile","block","ground","draw","lineWidth","beginPath","moveTo","lineTo","closePath","stroke","$","notify","addStyle","defaults","style","hammer","Hammer","Manager","Pan","Tap","event","taps","Press","Pinch","lastPan","on","e","type","freePan","deltaX","deltaY","scaleStartTileSize","freeZoom","scale","Mousetrap","panDown","panLeft","panUp","panRight","clientX","clientY","resizeTimeout","console"],"mappings":"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"}